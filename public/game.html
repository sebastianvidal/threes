<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3s - Game Room</title>

    <!-- Open Graph / iMessage preview -->
    <meta property="og:title" content="3s - The Low-Score Dice Game">
    <meta property="og:description" content="Play a round of 3s with me!">
    <meta property="og:image" content="https://threes-production-3fcb.up.railway.app/preview.png">
    <meta property="og:type" content="website">

    <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
    <div class="container">
        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Connecting...</p>
        </div>

        <!-- Lobby -->
        <div class="lobby-screen" id="lobby-screen">
            <h1>3s</h1>
            <p class="subtitle">The low-score dice game</p>

            <div class="room-code-display">
                <div class="room-code-label">Room Code</div>
                <div class="room-code" id="room-code">----</div>
                <button class="copy-link-btn" id="btn-copy-link">Copy Link</button>
            </div>

            <div class="player-list" id="player-list">
                <h3>Players</h3>
                <div id="player-list-content"></div>
            </div>

            <p class="waiting-message" id="waiting-message">Waiting for players...</p>

            <button class="btn-start" id="btn-start-game" disabled>Start Game</button>
            <button class="btn-new" id="btn-leave-lobby" style="width: 100%; margin-top: 10px;">Leave Room</button>
        </div>

        <!-- Game -->
        <div class="game-screen" id="game-screen">
            <h1>3s</h1>
            <p class="subtitle">The low-score dice game</p>

            <div class="current-player" id="current-player">Waiting...</div>

            <div class="score-board">
                <div class="score-item">
                    <div class="score-label">Rolls Left</div>
                    <div class="score-value" id="rolls-left">5</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Current Score</div>
                    <div class="score-value" id="current-score">0</div>
                </div>
            </div>

            <div class="dice-area">
                <div class="dice-section-label">Active Dice (tap to select)</div>
                <div class="dice-container" id="active-dice">
                    <div class="empty-dice">Waiting for turn...</div>
                </div>

                <div class="kept-area">
                    <div class="dice-section-label">Kept Dice</div>
                    <div class="dice-container kept-container" id="kept-dice"></div>
                    <div class="kept-score">Round points: <span id="kept-score">0</span></div>
                </div>
            </div>

            <div class="actions">
                <button class="btn-roll" id="btn-roll" disabled>Roll</button>
                <button class="btn-keep" id="btn-keep" disabled>Keep Selected</button>
            </div>

            <div class="message" id="message">Waiting for your turn...</div>

            <div class="other-players" id="other-players">
                <h3>Other Players</h3>
                <div id="other-players-content"></div>
            </div>


            <div class="rules">
                <h3>How to Play</h3>
                <ul>
                    <li><strong>3s = 0 points</strong> (best!)</li>
                    <li>All other dice = face value</li>
                    <li>Up to 5 rolls to set aside dice</li>
                    <li>Must keep at least 1 die per roll</li>
                    <li>Lowest score wins!</li>
                </ul>
            </div>
        </div>

        <!-- Results Modal -->
        <div class="modal-overlay" id="results-modal" style="display: none;">
            <div class="modal">
                <h2>Results</h2>
                <div class="modal-winner" id="modal-winner"></div>
                <div class="modal-scores" id="modal-scores"></div>
                <div class="rematch-status" id="rematch-status"></div>
                <button class="modal-btn" id="btn-rematch">Rematch</button>
                <button class="modal-btn secondary" id="btn-leave-game">Leave</button>
            </div>
        </div>

        <!-- Toast -->
        <div class="toast" id="toast"></div>
    </div>

    <!-- Floating Chat -->
    <button class="chat-fab" id="chat-fab">
        <span class="chat-fab-icon">ðŸ’¬</span>
        <span class="chat-fab-badge" id="chat-badge"></span>
    </button>
    <div class="chat-floating" id="chat-container">
        <div class="chat-header" id="chat-header">
            <h3>Chat</h3>
            <button class="chat-close" id="chat-close">âœ•</button>
        </div>
        <div class="chat-messages" id="chat-messages"></div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="Type a message..." maxlength="200">
            <button class="chat-send-btn" id="btn-send-chat">Send</button>
        </div>
    </div>

    <script src="/js/game-core.js"></script>
    <script src="/js/multiplayer.js"></script>
    <script>
        // Get room code from URL
        const params = new URLSearchParams(window.location.search);
        let roomCode = params.get('room');

        if (!roomCode) {
            window.location.href = '/';
        }

        // Game state
        let activeDice = [];
        let keptDice = [];
        let selectedIndices = new Set();
        let rollsLeft = 5;
        let isRolling = false;
        let hasRolledThisRound = false;
        let hasKeptThisRoll = false;
        let playerResults = {};

        // Spectating state (what current player is doing)
        let spectatingActive = [];
        let spectatingKept = [];
        let spectatingRolls = 5;

        // Connect and set up handlers
        async function init() {
            try {
                await Multiplayer.connect();

                // Check if we have pending room info from index.html
                const pendingRoom = localStorage.getItem('threes_pending_room');
                if (pendingRoom) {
                    const info = JSON.parse(pendingRoom);
                    if (info.roomCode === roomCode) {
                        localStorage.removeItem('threes_pending_room');
                        if (info.isHost) {
                            // Host needs to create room again (old connection closed)
                            Multiplayer.createRoom(info.nickname);
                        } else {
                            // Joiner can just join
                            Multiplayer.joinRoom(roomCode, info.nickname);
                        }
                        return;
                    }
                }

                // Try to reconnect to existing room (for page refresh)
                Multiplayer.send({
                    type: 'reconnect',
                    roomCode: roomCode,
                    sessionId: Multiplayer.sessionId
                });

                // If reconnect fails, redirect to join
                setTimeout(() => {
                    if (!Multiplayer.roomCode) {
                        window.location.href = `/join/${roomCode}`;
                    }
                }, 2000);

            } catch (err) {
                showToast('Failed to connect');
                setTimeout(() => window.location.href = '/', 2000);
            }
        }

        // Event handlers
        Multiplayer.on('room_joined', showLobby);
        Multiplayer.on('state_sync', handleStateSync);
        Multiplayer.on('player_joined', updatePlayerList);
        Multiplayer.on('player_left', updatePlayerList);
        Multiplayer.on('player_disconnected', updatePlayerList);
        Multiplayer.on('player_reconnected', updatePlayerList);
        Multiplayer.on('game_started', startGame);
        Multiplayer.on('turn_started', handleTurnStarted);
        Multiplayer.on('dice_rolled', handleDiceRolled);
        Multiplayer.on('dice_kept', handleDiceKept);
        Multiplayer.on('turn_ended', handleTurnEnded);
        Multiplayer.on('game_ended', handleGameEnded);
        Multiplayer.on('rematch_proposed', handleRematchProposed);
        Multiplayer.on('error', (data) => showToast(data.message));
        Multiplayer.on('room_closed', () => {
            showToast('Room closed');
            setTimeout(() => window.location.href = '/', 2000);
        });

        function showLobby(data) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('lobby-screen').style.display = 'block';
            document.getElementById('room-code').textContent = data.roomCode;
            // Update URL if room code changed (host created new room)
            if (data.roomCode !== roomCode) {
                window.history.replaceState({}, '', `/game.html?room=${data.roomCode}`);
                roomCode = data.roomCode;
            }
            updatePlayerList();
        }

        function handleStateSync(data) {
            if (data.status === 'waiting') {
                showLobby(data);
            } else if (data.status === 'playing') {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game-screen').style.display = 'block';

                // Restore game state
                const myIndex = Multiplayer.getMyIndex();
                if (data.game && data.game.playerStates && data.game.playerStates[myIndex]) {
                    const state = data.game.playerStates[myIndex];
                    activeDice = state.activeDice;
                    keptDice = state.keptDice;
                    rollsLeft = state.rollsLeft;
                    hasRolledThisRound = state.hasRolledThisRound;
                    hasKeptThisRoll = state.hasKeptThisRoll;
                }

                updateGameUI();
            }
        }

        function updatePlayerList() {
            const content = document.getElementById('player-list-content');
            content.innerHTML = Multiplayer.players.map(p => {
                const isHost = Multiplayer.players[0]?.id === p.id;
                const isYou = p.id === Multiplayer.playerId;
                const disconnected = !p.connected;

                return `
                    <div class="player-item ${disconnected ? 'disconnected' : ''}">
                        <span class="nickname">${escapeHtml(p.nickname)}${isYou ? '<span class="you-badge">You</span>' : ''}</span>
                        ${isHost ? '<span class="host-badge">Host</span>' : ''}
                    </div>
                `;
            }).join('');

            // Update start button
            const startBtn = document.getElementById('btn-start-game');
            startBtn.disabled = !Multiplayer.isHost || Multiplayer.players.length < 1;

            // Update waiting message
            const msg = document.getElementById('waiting-message');
            if (Multiplayer.isHost) {
                msg.textContent = Multiplayer.players.length < 2
                    ? 'Waiting for more players...'
                    : 'Ready to start!';
            } else {
                msg.textContent = 'Waiting for host to start...';
            }

            // Update other players in game view
            updateOtherPlayers();
        }

        function updateOtherPlayers() {
            const content = document.getElementById('other-players-content');
            if (!content) return;

            content.innerHTML = Multiplayer.players.map((p, i) => {
                if (p.id === Multiplayer.playerId) return '';

                const isCurrent = i === Multiplayer.currentPlayerIndex;
                const isDone = playerResults[p.id] !== undefined;

                return `
                    <div class="other-player-row ${isCurrent ? 'current' : ''} ${isDone ? 'done' : ''}">
                        <span class="other-player-name">${escapeHtml(p.nickname)}</span>
                        <span class="other-player-status ${isDone ? 'done' : ''}">
                            ${isDone ? playerResults[p.id] + ' pts' : (isCurrent ? 'Playing...' : 'Waiting')}
                        </span>
                    </div>
                `;
            }).join('');
        }

        function startGame(data) {
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';

            // Reset state
            activeDice = [];
            keptDice = [];
            selectedIndices.clear();
            rollsLeft = 5;
            hasRolledThisRound = false;
            hasKeptThisRoll = false;
            playerResults = {};

            updateGameUI();
        }

        function handleTurnStarted(data) {
            Multiplayer.currentPlayerIndex = data.currentPlayerIndex;

            // Reset spectating state
            spectatingActive = [];
            spectatingKept = [];
            spectatingRolls = 5;

            // Reset my state if it's my turn
            if (Multiplayer.isMyTurn()) {
                activeDice = [];
                keptDice = [];
                selectedIndices.clear();
                rollsLeft = 5;
                hasRolledThisRound = false;
                hasKeptThisRoll = false;
            }

            updateGameUI();
        }

        function handleDiceRolled(data) {
            if (data.playerId === Multiplayer.playerId) {
                activeDice = data.activeDice;
                keptDice = data.keptDice;
                rollsLeft = data.rollsLeft;
                hasRolledThisRound = true;
                hasKeptThisRoll = false;
                selectedIndices.clear();
                isRolling = false;
            } else {
                // Spectating another player
                spectatingActive = data.activeDice;
                spectatingKept = data.keptDice;
                spectatingRolls = data.rollsLeft;
            }
            updateGameUI();
        }

        function handleDiceKept(data) {
            if (data.playerId === Multiplayer.playerId) {
                activeDice = data.activeDice;
                keptDice = data.keptDice;
                hasKeptThisRoll = true;
                selectedIndices.clear();
            } else {
                // Spectating another player
                spectatingActive = data.activeDice;
                spectatingKept = data.keptDice;
            }
            updateGameUI();
        }

        function handleTurnEnded(data) {
            playerResults[data.playerId] = data.finalScore;

            if (data.playerId === Multiplayer.playerId) {
                // Show my final dice
                keptDice = data.finalDice;
                activeDice = [];
            } else {
                // Show their final dice for spectators
                spectatingKept = data.finalDice;
                spectatingActive = [];
            }

            // Show turn result message
            const player = Multiplayer.players.find(p => p.id === data.playerId);
            const msg = document.getElementById('message');
            const threes = data.finalDice.filter(d => d === 3).length;
            const comment = threes === 5 ? 'PERFECT!' : (threes >= 3 ? 'Nice!' : '');
            msg.innerHTML = `<strong>${escapeHtml(player?.nickname || 'Player')}</strong> finished with <strong>${data.finalScore} points</strong> ${comment}`;

            updateGameUI();
            updateOtherPlayers();
        }

        function handleGameEnded(data) {
            // Build results modal
            const winners = data.winners;
            const winnerText = winners.length === 1
                ? `ðŸŽ‰ ${escapeHtml(winners[0].nickname)} wins! ðŸŽ‰<br>with ${data.winningScore} points`
                : `It's a tie!<br>${winners.map(w => escapeHtml(w.nickname)).join(' & ')} with ${data.winningScore} points`;

            document.getElementById('modal-winner').innerHTML = winnerText;

            const scoresHtml = data.results.map(r => `
                <div class="modal-score-row ${r.isWinner ? 'winner-row' : ''}">
                    <span class="modal-player-name">${escapeHtml(r.nickname)}</span>
                    <span class="modal-player-dice">
                        ${r.dice.map(d => `<span class="modal-die ${d === 3 ? 'three' : ''}">${d}</span>`).join('')}
                    </span>
                    <span class="modal-player-score">${r.score}</span>
                </div>
            `).join('');

            document.getElementById('modal-scores').innerHTML = scoresHtml;
            document.getElementById('rematch-status').textContent = '';
            document.getElementById('results-modal').style.display = 'flex';
        }

        function handleRematchProposed(data) {
            const status = document.getElementById('rematch-status');
            status.textContent = `Rematch: ${data.acceptedCount}/${data.totalPlayers} players ready`;
        }

        function updateGameUI() {
            const isMyTurn = Multiplayer.isMyTurn();
            const currentPlayer = Multiplayer.getCurrentPlayer();

            // Update turn indicator
            const turnIndicator = document.getElementById('current-player');
            if (isMyTurn) {
                turnIndicator.textContent = "Your Turn!";
                turnIndicator.classList.add('your-turn');
            } else if (currentPlayer) {
                turnIndicator.textContent = `${currentPlayer.nickname}'s Turn`;
                turnIndicator.classList.remove('your-turn');
            }

            // Update dice
            renderDice();

            // Update scores (show spectating values if not your turn)
            const showRolls = isMyTurn ? rollsLeft : spectatingRolls;
            const showKept = isMyTurn ? keptDice : spectatingKept;
            document.getElementById('rolls-left').textContent = showRolls;
            document.getElementById('current-score').textContent = GameCore.calculateScore(showKept);

            // Update buttons
            const rollBtn = document.getElementById('btn-roll');
            const keepBtn = document.getElementById('btn-keep');

            const canRoll = isMyTurn && !isRolling && rollsLeft > 0 &&
                           (activeDice.length === 0 || hasKeptThisRoll || !hasRolledThisRound);
            const canKeep = isMyTurn && !isRolling && selectedIndices.size > 0;

            rollBtn.disabled = !canRoll;
            keepBtn.disabled = !canKeep;

            // Update message
            updateMessage(isMyTurn);
        }

        function renderDice() {
            const activeContainer = document.getElementById('active-dice');
            const keptContainer = document.getElementById('kept-dice');
            const isMyTurn = Multiplayer.isMyTurn();

            // Decide which dice to show
            const showActive = isMyTurn ? activeDice : spectatingActive;
            const showKept = isMyTurn ? keptDice : spectatingKept;

            // Active dice
            if (showActive.length === 0) {
                if (isMyTurn && !hasRolledThisRound) {
                    activeContainer.innerHTML = '<div class="empty-dice">Press Roll to start</div>';
                } else if (isMyTurn) {
                    activeContainer.innerHTML = '<div class="empty-dice">All dice kept</div>';
                } else if (spectatingKept.length === 0 && spectatingActive.length === 0) {
                    const current = Multiplayer.getCurrentPlayer();
                    activeContainer.innerHTML = `<div class="empty-dice">Waiting for ${current?.nickname || 'player'} to roll...</div>`;
                } else {
                    activeContainer.innerHTML = '<div class="empty-dice">All dice kept</div>';
                }
            } else {
                activeContainer.innerHTML = showActive.map((d, i) => {
                    const isThree = d === 3;
                    const isSelected = isMyTurn && selectedIndices.has(i);
                    const disabled = !isMyTurn;
                    return `<div class="die ${isThree ? 'three' : ''} ${isSelected ? 'selected' : ''} ${disabled ? 'disabled' : ''}"
                                data-index="${i}">${d}</div>`;
                }).join('');
            }

            // Kept dice
            if (showKept.length === 0) {
                keptContainer.innerHTML = '';
            } else {
                keptContainer.innerHTML = showKept.map(d => {
                    const isThree = d === 3;
                    return `<div class="die kept ${isThree ? 'three' : ''}">${d}</div>`;
                }).join('');
            }

            // Update kept score display
            document.getElementById('kept-score').textContent = GameCore.calculateScore(showKept);
        }

        function updateMessage(isMyTurn) {
            const msg = document.getElementById('message');

            if (!isMyTurn) {
                const current = Multiplayer.getCurrentPlayer();
                if (!current) {
                    msg.textContent = 'Waiting...';
                } else if (spectatingActive.length > 0) {
                    const threes = spectatingActive.filter(d => d === 3).length;
                    if (threes > 0) {
                        msg.textContent = `${current.nickname} rolled ${threes} three${threes > 1 ? 's' : ''}!`;
                    } else {
                        msg.textContent = `${current.nickname} is choosing dice to keep...`;
                    }
                } else if (spectatingKept.length > 0) {
                    msg.textContent = `${current.nickname} has ${spectatingRolls} roll${spectatingRolls !== 1 ? 's' : ''} left...`;
                } else {
                    msg.textContent = `Watching ${current.nickname}...`;
                }
                return;
            }

            if (!hasRolledThisRound) {
                msg.textContent = "Roll the dice! Try to get 3s (worth 0 points).";
            } else if (hasRolledThisRound && !hasKeptThisRoll && activeDice.length > 0) {
                msg.textContent = "Keep at least 1 die before rolling again.";
            } else if (rollsLeft > 0 && activeDice.length > 0) {
                const threes = activeDice.filter(d => d === 3).length;
                if (threes > 0) {
                    msg.textContent = `Nice! ${threes} three${threes > 1 ? 's' : ''}! Select dice to keep.`;
                } else {
                    msg.textContent = `${rollsLeft} roll${rollsLeft > 1 ? 's' : ''} left. Select dice to keep.`;
                }
            } else if (rollsLeft === 0) {
                msg.textContent = "No rolls left.";
            }
        }

        // Event listeners
        document.getElementById('active-dice').addEventListener('click', (e) => {
            const die = e.target.closest('.die');
            if (die && !die.classList.contains('disabled') && die.dataset.index !== undefined) {
                const index = parseInt(die.dataset.index);
                if (selectedIndices.has(index)) {
                    selectedIndices.delete(index);
                } else {
                    selectedIndices.add(index);
                }
                renderDice();
                document.getElementById('btn-keep').disabled = selectedIndices.size === 0;
            }
        });

        document.getElementById('btn-roll').addEventListener('click', () => {
            if (!Multiplayer.isMyTurn() || isRolling) return;
            isRolling = true;
            Multiplayer.roll();
        });

        document.getElementById('btn-keep').addEventListener('click', () => {
            if (!Multiplayer.isMyTurn() || selectedIndices.size === 0) return;
            Multiplayer.keepDice(Array.from(selectedIndices));
        });

        document.getElementById('btn-start-game').addEventListener('click', () => {
            if (Multiplayer.isHost) {
                Multiplayer.startGame();
            }
        });

        document.getElementById('btn-copy-link').addEventListener('click', () => {
            const url = `${window.location.origin}/join/${Multiplayer.roomCode}`;
            navigator.clipboard.writeText(url).then(() => {
                showToast('Link copied!');
            }).catch(() => {
                showToast('Failed to copy');
            });
        });

        document.getElementById('btn-leave-lobby').addEventListener('click', () => {
            Multiplayer.leaveRoom();
            window.location.href = '/';
        });

        document.getElementById('btn-rematch').addEventListener('click', () => {
            Multiplayer.requestRematch();
            document.getElementById('btn-rematch').textContent = 'Waiting...';
            document.getElementById('btn-rematch').disabled = true;
        });

        document.getElementById('btn-leave-game').addEventListener('click', () => {
            Multiplayer.leaveRoom();
            window.location.href = '/';
        });

        // When rematch starts
        Multiplayer.on('rematch_started', () => {
            document.getElementById('results-modal').style.display = 'none';
            document.getElementById('btn-rematch').textContent = 'Rematch';
            document.getElementById('btn-rematch').disabled = false;
            startGame({});
        });

        // Chat handling
        let unreadMessages = 0;

        Multiplayer.on('chat', (data) => {
            addChatMessage(data.nickname, data.text, data.playerId === Multiplayer.playerId);
        });

        function addChatMessage(nickname, text, isMe) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'chat-message' + (isMe ? ' me' : '');
            messageEl.innerHTML = `<span class="chat-nickname">${escapeHtml(nickname)}</span><span class="chat-text">${escapeHtml(text)}</span>`;
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Show badge if chat is closed and message is from someone else
            if (!isMe) {
                const container = document.getElementById('chat-container');
                if (!container.classList.contains('open')) {
                    unreadMessages++;
                    updateChatBadge();
                }
            }
        }

        function updateChatBadge() {
            const badge = document.getElementById('chat-badge');
            if (unreadMessages > 0) {
                badge.textContent = unreadMessages > 9 ? '9+' : unreadMessages;
                badge.style.display = 'inline-block';
            } else {
                badge.style.display = 'none';
            }
        }

        function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            if (text) {
                Multiplayer.sendChat(text);
                input.value = '';
            }
        }

        document.getElementById('btn-send-chat').addEventListener('click', sendChatMessage);

        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });

        document.getElementById('chat-fab').addEventListener('click', () => {
            const container = document.getElementById('chat-container');
            container.classList.add('open');
            unreadMessages = 0;
            updateChatBadge();
            document.getElementById('chat-input').focus();
        });

        document.getElementById('chat-close').addEventListener('click', () => {
            document.getElementById('chat-container').classList.remove('open');
        });

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Start
        init();
    </script>
</body>
</html>
